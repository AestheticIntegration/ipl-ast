[@@@program]

[@@@require "decoders-yojson"]

[@@@import "itr_ast.iml"]

[@@@import "../src-core-pp/datetime_json.iml"]

open Itr_ast
open Decoders_yojson.Basic.Decode
open Datetime_json

let name_and_index_decoder : (string * int option) decoder =
  let* name = field "name" string in
  let* index = field "index" (nullable int) in
  let index = match index with None -> None | Some i -> Some (Z.of_int i) in
  succeed (name, index)


let message_value_decoder : Message_value.t decoder =
  let* var_name = field "var_name" (nullable string) in
  let var = match var_name with None -> None | Some v -> Some v in
  let* field_path = field "field_path" (list name_and_index_decoder) in
  let mv : Message_value.t = { var; field_path } in
  succeed mv


let datetime_decoder : datetime decoder =
  single_field (function
      | "UTCTimestamp" ->
          let+ u = utctimestamp_micro_decoder in
          UTCTimestamp u
      | "UTCTimeOnly" ->
          let+ u = utctimeonly_micro_decoder in
          UTCTimeOnly u
      | "UTCDateOnly" ->
          let+ u = utcdateonly_decoder in
          UTCDateOnly u
      | "LocalMktDate" ->
          let+ u = localmktdate_decoder in
          LocalMktDate u
      | "MonthYear" ->
          let+ u = monthyear_decoder in
          MonthYear u
      | "Duration" ->
          let+ u = duration_decoder in
          Duration u
      | s ->
          fail @@ "unrecognised datetime: " ^ s )


let rec literal_decoder () : literal decoder =
  single_field (function
      | "Bool" ->
          let+ b = bool in
          Bool b
      | "Int" ->
          let+ i = string in
          Int (Z.of_string i)
      | "String" ->
          let+ s = string in
          ( match String.sub s 1 (String.length s - 2) with
          | None ->
              String ""
          | Some s ->
              String s )
      | "Float" ->
          let+ q = float in
          Float (Q.of_float q)
      | "Coll" ->
          let+ c =
            list
              (one_of
                 [ ("record_item", record_item_decoder ())
                 ; ( "expr"
                   , let+ e = expr_decoder () in
                     Rec_value e )
                 ] )
          in
          Coll c
      | "MapColl" ->
          let* d = field "default" (record_item_decoder ()) in
          let+ c = field "elements" (list (record_item_pair_decoder ())) in
          MapColl (d, c)
      | "None" ->
          succeed LiteralNone
      | "Some" ->
          let+ e =
            one_of
              [ ("record_item", record_item_decoder ())
              ; ( "expr"
                , let+ e = expr_decoder () in
                  Rec_value e )
              ]
          in
          LiteralSome e
      | "Datetime" ->
          let+ d = datetime_decoder in
          Datetime d
      | s ->
          fail @@ "unrecognised literal: " ^ s )


and record_item_pair_decoder () :
    (Itr_ast.record_item * Itr_ast.record_item) decoder =
  let* key = field "key" (record_item_decoder ()) in
  let* value = field "value" (record_item_decoder ()) in
  succeed (key, value)


and value_decoder () : Itr_ast.value decoder =
  single_field (function
      | "Literal" ->
          let+ l = literal_decoder () in
          Literal l
      | "Variable" ->
          let+ v = string in
          Variable v
      | "Message_value" ->
          let+ mv = message_value_decoder in
          MessageValue mv
      | "ObjectProperty" ->
          let* obj =
            field
              "obj"
              (one_of
                 [ ("record_item", record_item_decoder ())
                 ; ( "expr"
                   , let+ e = expr_decoder () in
                     Rec_value e )
                 ] )
          in
          let* index = field "index" (nullable int) in
          let index = CCOption.map (fun x -> Z.of_int x) index in
          let* prop = field "prop" string in
          succeed (ObjectProperty { obj; index; prop })
      | "Funcall" ->
          let* func = field "name" string in
          let* args =
            field
              "args"
              (list
                 (one_of
                    [ ("record_item", record_item_decoder ())
                    ; ( "expr"
                      , let+ e = expr_decoder () in
                        Rec_value e )
                    ] ) )
          in
          succeed (Funcall { func; args })
      | "CaseSplit" ->
          let* default_value = field "default_value" (record_item_decoder ()) in
          let+ cases =
            field
              "cases"
              (list
                 (let* check = field "check" (record_item_decoder ()) in
                  let+ value = field "value" (record_item_decoder ()) in
                  (check, value) ) )
          in
          CaseSplit { default_value; cases }
      | "DataSetValue" ->
          let* name = field "name" string in
          let* field_name = field "field_name" string in
          let* default = field "default" (record_item_decoder ()) in
          (*  ("constraints", `List (List.map record_item_to_json constraints))*)
          let+ constraints =
            field "constraints" (list (record_item_decoder ()))
          in
          DataSetValue { name; field_name; default; constraints }
      | s ->
          fail @@ "unrecognised value:" ^ s )


and expr_decoder () : expr decoder =
  single_field (function
      | "Value" ->
          let+ v = value_decoder () in
          Value v
      | "Not" ->
          let+ n = expr_decoder () in
          Not n
      | "Or" ->
          let* lhs = field "lhs" (expr_decoder ()) in
          let* rhs = field "rhs" (expr_decoder ()) in
          succeed (Or { lhs; rhs })
      | "And" ->
          let* lhs = field "lhs" (expr_decoder ()) in
          let* rhs = field "rhs" (expr_decoder ()) in
          succeed (And { lhs; rhs })
      | "Eq" ->
          let* lhs =
            one_of
              [ ("record_item", field "lhs" (record_item_decoder ()))
              ; ( "expr"
                , field
                    "lhs"
                    (expr_decoder () >>= fun e -> succeed (Rec_value e)) )
              ]
          in
          let+ rhs =
            one_of
              [ ("record_item", field "rhs" (record_item_decoder ()))
              ; ( "expr"
                , field
                    "rhs"
                    (expr_decoder () >>= fun e -> succeed (Rec_value e)) )
              ]
          in
          Eq { lhs; rhs }
      | "Cmp" ->
          let* lhs = field "lhs" (expr_decoder ()) in
          let* op = field "op" string in
          let* rhs = field "rhs" (expr_decoder ()) in
          succeed (Cmp { lhs; op; rhs })
      | "Add" ->
          let* lhs = field "lhs" (expr_decoder ()) in
          let* op = field "op" string in
          let op =
            match String.sub op 0 1 with None -> '+' | Some c -> c.[0i]
          in
          let* rhs = field "rhs" (expr_decoder ()) in
          succeed (Add { lhs; op; rhs })
      | "Mul" ->
          let* lhs = field "lhs" (expr_decoder ()) in
          let* op = field "op" string in
          let op =
            match String.sub op 0 1 with None -> '*' | Some c -> c.[0i]
          in
          let* rhs = field "rhs" (expr_decoder ()) in
          succeed (Mul { lhs; op; rhs })
      | "In" ->
          let* el = field "el" (expr_decoder ()) in
          let* set = field "set" (value_decoder ()) in
          succeed (In { el; set })
      | s ->
          fail @@ "unrecognised expr: " ^ s )


and record_item_decoder () : record_item decoder =
  single_field (function
      | "Rec_value" ->
          let+ v = expr_decoder () in
          Rec_value v
      | "Rec_record" ->
          let+ is = record_decoder () in
          Rec_record is
      | "Rec_repeating_group" ->
          let* num_in_group_field = field "num_in_group_field" string in
          let* elements = field "elements" (list (record_decoder ())) in
          let* name = field "name" string in
          let* message_template = field "message_template" (nullable string) in
          succeed
            (Rec_repeating_group
               { num_in_group_field; elements; name; message_template } )
      | s ->
          fail @@ "unrecognised record_item: " ^ s )


and record_decoder () : record decoder =
  field
    "Record"
    (let* elements =
       field
         "elements"
         (list
            (let* name = field "name" string in
             let* record_item = field "record_item" (record_item_decoder ()) in
             succeed (name, record_item) ) )
     in
     let* name = field "name" string in
     succeed { name; elements = String_map.of_list elements } )


let expecting_decoder : expecting decoder =
  one_of
    [ ( "combined_expressions"
      , let+ exprs = field "exprs" (list (expr_decoder ())) in
        { relevant_exprs = exprs
        ; nullable_exprs = []
        ; qe_modified_exprs = []
        ; common_exprs = []
        } )
    ; ( "structured_expressions"
      , let* relevant_exprs = field "relevant_exprs" (list (expr_decoder ())) in
        let* common_exprs = field "common_exprs" (list (expr_decoder ())) in
        let* nullable_exprs =
          field
            "nullable_exprs"
            (one_of
               [ ( "single_nullable"
                 , list
                     (let* field_paths =
                        field "field_paths" (list (list name_and_index_decoder))
                      in
                      let+ expr = field "expr" (expr_decoder ()) in
                      (expr, CCList.map (fun x -> [ x ]) field_paths) ) )
               ; ( "set_nullable"
                 , list
                     (let* field_paths =
                        field
                          "field_paths"
                          (list (list (list name_and_index_decoder)))
                      in
                      let+ expr = field "expr" (expr_decoder ()) in
                      (expr, field_paths) ) )
               ] )
        in
        let+ qe_modified_exprs =
          field "qe_modified_exprs" (list (expr_decoder ()))
        in
        { relevant_exprs; nullable_exprs; qe_modified_exprs; common_exprs } )
    ]


let field_decoder () : field decoder =
  let* name = field "name" string in
  let+ value = field "value" (record_item_decoder ()) in
  { name; value }


let instruction_decoder () : instruction decoder =
  single_field (function
      | "Action" ->
          let* name = field "name" string in
          let+ fields = field "fields" (list (field_decoder ())) in
          Action { name; fields }
      | "Message" ->
          let* name = field "name" string in
          let+ fields = field "fields" (list (field_decoder ())) in
          Message { name; fields }
      | "Set" ->
          let* prop = field "prop" string in
          let* value = field "value" (record_item_decoder ()) in
          succeed (Set { prop; value })
      | "Send" ->
          let* variable = field "variable" (nullable string) in
          let* tag = field "tag" string in
          let* withs = field "withs" (nullable (record_decoder ())) in
          succeed (Send { variable; tag; withs })
      | "Receive" ->
          let* variable = field "variable" (nullable string) in
          let* where = field "where" (expr_decoder ()) in
          let* expecting = field "expecting" (nullable expecting_decoder) in
          let+ example = field "example" (record_decoder ()) in
          Receive { variable; where; expecting; example }
      | "Prompt" ->
          let* prop = field "prop" string in
          let+ and_set = field "and_set" bool in
          Prompt { prop; and_set }
      | _ ->
          fail "unrecognised instruction" )


let instructions_decoder :
    (instruction list * Model_messages.model_msg_opt_def list) decoder =
  let* instructions = field "instructions" (list (instruction_decoder ())) in
  let* msgs =
    field "msgs" (list Json_to_message.model_message_decoder_opt_def)
  in
  succeed (instructions, msgs)


[@@@logic]
